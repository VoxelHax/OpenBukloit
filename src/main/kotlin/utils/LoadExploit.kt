package utils

import cli.Logs
import com.github.ajalt.mordant.rendering.TextColors.*
import com.rikonardo.cafebabe.ClassFile
import com.rikonardo.cafebabe.Method
import com.rikonardo.cafebabe.data.constantpool.ConstantUtf8
import java.io.File
import java.lang.management.ManagementFactory
import java.util.regex.Pattern

private fun findClassRecursive(directory: File): File {
    if (!directory.isDirectory) return directory
    for (file in directory.listFiles()!!) {
        return findClassRecursive(file)
    }
    throw Exception("Could not find built class")
}

fun loadExploit(external: String?): ClassFile {
    val exploit: ClassFile
    if (external != null) {
        val file = File(external)
        if (!file.exists()) {
            throw Exception("File \"${file.canonicalPath}\" not found")
        }
        if (external.endsWith(".java")) {
            val jdk = requireJDK(52, 0)
            Logs.info("Compiling \"${file.canonicalPath}\"")
            val outputDir = File("./.openbukloit/temp/exploit")
            outputDir.mkdirs()

            val process = ProcessBuilder(
                jdk.toFile().canonicalPath,
                "-encoding", "utf8",
                "-cp", getClassPathArg(ManagementFactory.getRuntimeMXBean().classPath),
                "-d", outputDir.canonicalPath,
                file.canonicalPath
            ).start()
            process.errorStream.bufferedReader().use { bufferedReader ->
                bufferedReader.lines().forEach {
                    Logs.error(it)
                }
            }

            process.waitFor()
            val result = process.exitValue()
            if (result != 0) {
                throw Exception("Compilation failed with exit code $result")
            }

            val compiledClass = findClassRecursive(outputDir)
            exploit = ClassFile(compiledClass.readBytes())
            outputDir.deleteRecursively()
            Logs.info(
                "External exploit class compiled and loaded: \"${
                    brightCyan(exploit.name.replace("/", "."))
                }\" (class version: ${
                    brightCyan(exploit.version.toString())
                } / Java ${
                    brightCyan(getJavaVersion(exploit.version.major, exploit.version.minor))
                })"
            )
        } else {
            exploit = ClassFile(file.readBytes())
            Logs.info(
                "External exploit class loaded: \"${
                    brightCyan(exploit.name.replace("/", "."))
                }\" (class version: ${
                    brightCyan(exploit.version.toString())
                } / Java ${
                    brightCyan(getJavaVersion(exploit.version.major, exploit.version.minor))
                })"
            )
        }
    } else {
        exploit = ClassFile(getBytesFromInputStream(::loadExploit::class.java.getResourceAsStream("/Exploit.class")!!))
    }

    return exploit
}

class PreparedExploit(classFile: ClassFile) {
    val binary = classFile.compile()
    val params: List<String>

    init {
        classFile.findInjectMethod()
        val params = mutableListOf<String>()
        val pattern = Pattern.compile("%(.*?)%")
        for (entry in classFile.constantPool.entries) {
            if (entry is ConstantUtf8) {
                val matcher = pattern.matcher(entry.value)
                while (matcher.find()) {
                    val g = matcher.group()
                    val s = g.substring(1, g.length - 1)
                    if (!s.matches("[a-z_]+".toRegex())) throw Exception("Invalid parameter name: \"$s\"")
                    if (!params.contains(s)) params.add(s)
                }
            }
        }
        this.params = params.toList()
    }

    fun make(params: Map<String, String>): ClassFile {
        val classFile = ClassFile(binary)
        for (entry in classFile.constantPool.entries) {
            if (entry is ConstantUtf8) {
                for (param in this.params) {
                    val value = params[param]!!
                    entry.value = entry.value.replace("%$param%", value).replace("\\%", "%")
                }
            }
        }
        return classFile
    }
}

fun ClassFile.findInjectMethod(): Method {
    return this.methods.find {
        it.name == "inject" && it.descriptor == "(Lorg/bukkit/plugin/java/JavaPlugin;)V"
    } ?: throw Exception("Could not find inject method in exploit class")
}